<html>

<head>

  <meta name="author" content="Andy Seaborne"/>
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <meta http-equiv="Content-Language" content="en-gb">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">

  <meta name="DC.Creator"    content="Andy Seaborne">
  <meta name="DC.Publisher"  content="">
  <meta name="DC.Title"      content="Joseki: Queries and Operations on Models">
  <meta name="DC.Rights"
        content="Copyright 2003, 2004, Hewlett-Packard Development Company LP">
  <meta name="DC.Identifier"
        content="http://www.joseki.org/processors.html">
  <meta name="DC.Format"     content="text/html; charset=iso-8859-1">
  <meta name="DC.Date"       content="$Date: 2004-11-03 10:14:57 $">
  <meta name="DC.Type"       content="web page">

<title>Joseki: Queries and Operations on Models</title>
<link rel="stylesheet" type="text/css" href="StyleSheets/joseki.css">

</head>

<body>
<h1>Processors: Adding new query languages and other operations</h1>

<h2>Design</h2>

<p>Processors, query processors and processors for other operations,
deliver the functionality of a Joseki server.  Everything a client can
request of a model is performed by a processor.</p>

<p>Processors are dynamically loaded at start-up.&nbsp; They are
<a href="modules.html">modules</a>, th eunit of loading code into a Joseki 
server. The configuration file contains the information to identify a query 
language by some short name, or it long URI, and associate it with a query 
processor. For other processors, the binding on a model gives the operation a 
short name and points to the code for the operation.</p>

<p>Query requests identify the model on which to operate, the query language and 
the query itself.&nbsp; They return a single subgraph.&nbsp; At this level, 
query is subgraph extraction; a client library may wish to build variable 
bindings from such a subgraph and so the subgraph include all the information 
need for a particular language to do so. If no query language is specified 
(so there is no HTTP GET query string), the request is interpreted as a plain GET, fetch the 
whole model, just like browser use of HTTP GET.</p>
<p>All other operation requests identify the model on which to operate, provides 
some parameters, simple name/value pairs, and zero or one argument models.&nbsp; 
They return a single model.</p>

<p>Example queries.:</p>

<ul>
  <li><code>GET http://host/model</code><br>Fetch the whole of the target
model.</li>
  <li><code>GET http://host/model?lang=RDQL& \<br>
&nbsp;&nbsp;&nbsp;&nbsp; query=SELECT%20*%20WHERE%20(%3fx%2c%20%3fy%2c%20
%3fz)</code>
<br>
Perform a query specified in RDQL &#8211; a single subgraph is returned.
The query string is the encoded form of "SELECT * WHERE (?x, ?y, ?z)"
</ul>

<p>The subgraph returned in the RDQL query is guaranteed to be such that the 
same query issued on this subgraph would give the same bindings. The client 
library reconstructs the variable bindings locally.</p>


<h2>Dispatch</h2>

<p>Any incoming request is first turned into a Java form (class
<code>Request</code>) that records 
parameters and the argument model, if any.  Queries have the query
language recorded.  The implementer of a processor does not need
to know about the encoding/decoding details of the transport used.
</p>

<h2>Query over HTTP GET</h2>

<p>For an HTTP GET request, the query and the query language are given as
strings.  These become the "query" and "lang" parameters.</p>


<h2>Query over HTTP POST</h2>

<p>Some queries are too big to go via HTTP GET, or an application needs 
to bypass caches to ensure a query against the current state is done.
For this, the request puts the query into an RDF graph with a simple, known
vocabulary.  The query can just be a large RDF literal or structured RDF,
depending on the style of the query language.  The only requirement the 
adapter processor makes is that there is a single instance of the property
that names the query language.  If there is use of the property that
says there is a query string, a call to the underlying query processor is
made with the query as a string, otherwise the query model is used.  
The interface for a query processor captures these details.
</p>

<h2>Other operations over HTTP POST</h2>

<p>All general operations, such as "add", only come via HTTP POST.
This allows a more general argument passing mechanism and ensures that 
operations are sent to the target model itself, rather than a web cache.
If the operation is something that is cacheable, or bookmarkable, think of it as 
a query and then the full power of caching HTTP GETs will be available.</p>

<h2>Writing a QueryProcessor</h2>

<p>Query processors must supply the interface:</p>

<pre class="box">public interface QueryProcessor extends Processor
{
    public Model execQuery(Model model, String queryString)
       throws RDFException, QueryExecutionException ;
    public Model execQuery(Model model, Model queryModel)
       throws RDFException, QueryExecutionException ;
}
</pre>
<p>Queries are always
read-only operations.  There is a class <code>QueryProcessorCom</code> in
the
processors package <code>org.joseki.server.processors</code> that will be suitable much of the time so let's look at a
possible GET processor (at the time of writing this is the code for the GET
processor):
</p>

<pre class="box">public class QueryProcessorGET extends QueryProcessorCom
{
    public QueryProcessorGET() { super() ; }

    // The module interface requires ...
    public String getOperationURI()
    { return JosekiVocab.queryOperationGET ; }

    public Model execQuery(AttachedModel aModel, String queryString)
        throws RDFException, QueryExecutionException
    {
        if ( aModel.getIsImmutable() )
            return aModel.getModel() ;
        // Muatble model - need to take a copy as it may change
        // or be chaning when the reply is sent.
        Model result = new ModelMem() ;
        result.add(aModel.getModel()) ;
        return result ;
    }

    public Model execQuery(AttachedModel aModel, Model queryModel)
        throws RDFException, QueryExecutionException
    {
        throw new QueryExecutionException(
                       ExecutionError.rcOperationNotSupported,
                       "Can't GET a model this way") ;
    }

}
</pre>
<p>This query processor specifies its URI (all modules have a URI so that we
can make assertions about them) and supplies implementations of the
<code>execQuery</code> methods.  For GET, it just returns the model, or
a copy of the model if it might change.  Note that it throws an error if invoked
via HTTP POST.
</p>

<p>Once there is a class that provides the query language, it is bound to
<code>AttachedModels</code>.  See the <a
href="configuration.html">configuration</a>
section and the <code>hasQueryOperation</code> property.</p>



<h2>Writing an Operation Processor</h2>

<pre class="box">public interface Processor extends Loadable
{

    public Model exec(Request request) throws ExecutionException ;
    
    static final int ARGS_ZERO         = 0 ;
    static final int ARGS_ONE          = 1 ;
    static final int ARGS_ZERO_OR_ONE  = -1 ;
    
    public int argsNeeded() ;
}
</pre>

<p>A processor must provide its URI to identify it, and provide an
implementation of
<code>exec</code>.  There are some convenience declarations of
constants.</p>

<p>Once there is a class that implements the operation, it needs to be
bound to
the models it applies to.  See the <a
href="configuration.html">configuration</a>
section and the <code>hasOperation</code> property on
<code>AttachedModels</code>.</p>

<p>To help, there are two abstract classes,
<code>OneArgProcessor</code> and <code>ZeroArgProcessor</code>,
to help implementers for the cases of operations taking one or zero models as 
arguments (they can have any number of parameters).&nbsp; These implementations provide locking.<h2>Concurrency</h2>

<p>In the example of query GET, the operation checked to see if it needed to return a copy of the
model, not
the model itself.  This is because the read-lock (all queries are done
under a
read-lock if they use the standard query processor framework) only covers
the time
the operation is being performed, not the time it is being encoded and
written back
over the transport. </p>

<p>Operation processors must be safe during their execution and also safe
in their
results.  In the standard implementations for processors,
<code>OneArgProcessor</code> and <code>ZeroArgProcessor</code>,
insist on at least a read-lock (its a multiple-reader, single writer lock).
</p>



<hr>
<div class="footer">
<p align="right">$Date: 2004-11-03 10:14:57 $ // $Revision: 1.1 $ // $Author: andy_seaborne $</p>
</div>
</body>
</html>