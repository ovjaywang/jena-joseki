## Run with: http_proxy= cwm ex-cwm --think --strings

@prefix log:      <http://www.w3.org/2000/10/swap/log#>.
@prefix string:   <http://www.w3.org/2000/10/swap/string#>.
@prefix rdfs:     <http://www.w3.org/2000/01/rdf-schema#> .
@prefix rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .

@prefix model:    <http://localhost:2020/rdfserver/joseki-example> .
@prefix :         <#> .
@prefix dc:       <http://purl.org/dc/elements/1.1/> .

@prefix obj:      <http://jena.hpl.hp.com/objects#> .


## ----------------------------------------------
## Data for the query

:ObjectRef1 a :ObjectRef ;
    obj:rep "http://localhost:2020/joseki-example" ;
    # This must be %-encoded.
    obj:obj "http://example.org/book/book1"
    .

:ObjectRef2 a :ObjectRef ;
    obj:rep "http://localhost:2020/joseki-example" ;
    # This must be %-encoded.
    obj:obj "http://example.org/book/book2"
    .


## ----------------------------------------------
## RULE:: For each object, find its dc:title

this log:forAll :c, :t .

{ ?x obj:contents ?thing .
  ?thing log:includes {:c dc:title :t } .
   ("Title: " :t "\n" ) string:concatenation ?out .
} => { :1 log:outputString ?out } .


## ----------------------------------------------
## RULE:: Convert the object reference to a URI

{ ?objRef obj:rep ?rep .
  ?objRef obj:obj ?obj .
  ( ?rep
    "?lang=fetch&r="
    ?obj ) string:concatenation ?access .
} => { ?objRef obj:uri ?access }.
       ## log:uri is magic : can't assert it directly


## ----------------------------------------------
## RULE:: Get the contents, given a URI

{ ?x  obj:uri        ?access . 
  ## log:uri is magic : can't assert it directly
  ?y  log:uri        ?access .
  ?y  log:semantics  ?thing . } =>
{ ?x  obj:contents   ?thing } .


# Local Variables:
# tab-width: 4
# indent-tabs-mode: nil
# End:
